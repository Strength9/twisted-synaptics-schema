generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x"]
  engineType    = "binary"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================================================
// UNIFIED USER MODELS (Both admin and frontend use SiteUser)
// ============================================================================

model SiteUser {
  id                   String                   @id @default(uuid())
  email                String                   @unique
  emailVerified        Boolean                  @default(false)
  name                 String?
  image                String?
  role                 String                   @default("user")
  restricted           Boolean                  @default(false)
  // Access control: determine which apps this user can access
  canAccessAdmin       Boolean                  @default(false)  @map("can_access_admin")
  canAccessTenant      Boolean                  @default(false)  @map("can_access_tenant")
  // Admin-specific fields (nullable for tenant-only users)
  avatar               String?
  colorLight           String?                  @unique(map: "site_users_color_light_unique") @map("color_light") @db.VarChar(7)
  colorDark            String?                  @unique(map: "site_users_color_dark_unique") @map("color_dark") @db.VarChar(7)
  displayOrder         Int?                     @map("display_order")
  timezone             String?                  @default("UTC")
  tenantId             String?                  @map("tenant_id")
  // Track where user signed up (for regular users/players)
  signupTenantId       String?                  @map("signup_tenant_id")
  // Suspension system (global, affects all access)
  isSuspended          Boolean                  @default(false) @map("is_suspended")
  suspendedAt          DateTime?                @map("suspended_at")
  suspendedBy          String?                  @map("suspended_by")
  suspensionReason     String?                  @map("suspension_reason")
  // Activity tracking (for all users)
  lastLoginAt          DateTime?                @map("last_login_at")
  loginCount           Int                      @default(0) @map("login_count")
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  // Relations
  accounts             Account[]
  sentInvites          AdminInvite[]
  tenant               Tenant?                  @relation(fields: [tenantId], references: [id])
  signupTenant         Tenant?                  @relation("SignupTenant", fields: [signupTenantId], references: [id])
  adminAuditLogs       AuditLog[]               @relation("AdminAuditLogs")
  userAuditLogs        AuditLog[]               @relation("UserAuditLogs")
  sessions             Session[]
  dashboardPreferences UserDashboardPreference?
  userTenants          UserTenant[]
  userPasswordResetTokens UserPasswordResetToken[]
  // Scheduled tasks relations (who created/updated/deleted tasks)
  scheduledTasksCreated ScheduledTask[]         @relation("ScheduledTaskCreatedBy")
  scheduledTasksUpdated ScheduledTask[]         @relation("ScheduledTaskUpdatedBy")
  scheduledTasksDeleted ScheduledTask[]         @relation("ScheduledTaskDeletedBy")
  scheduledTaskLogs     ScheduledTaskLog[]      @relation("ScheduledTaskLogTriggeredBy")

  @@index([tenantId])
  @@index([signupTenantId])
  @@index([role])
  @@index([colorLight])
  @@index([colorDark])
  @@index([canAccessAdmin])
  @@index([canAccessTenant])
  @@index([isSuspended])
  @@index([lastLoginAt])
  @@map("site_users")
}

model AdminInvite {
  id        String    @id @default(uuid())
  email     String
  token     String    @unique
  role      String    @default("admin")
  invitedBy String
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  tenantId  String?   @map("tenant_id")
  inviter   SiteUser  @relation(fields: [invitedBy], references: [id])

  @@index([email])
  @@index([token])
  @@index([tenantId])
  @@map("admin_invites")
}

model PasswordReset {
  id        String    @id @default(uuid())
  email     String
  token     String    @unique
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([email])
  @@index([token])
  @@map("password_resets")
}

model EmailVerification {
  id        String    @id @default(uuid())
  email     String
  token     String    @unique
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([email])
  @@index([token])
  @@map("email_verifications")
}

model Session {
  id        String    @id @default(uuid())
  userId    String
  expiresAt DateTime
  token     String    @unique
  ipAddress String?
  userAgent String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      SiteUser  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model UserPasswordResetToken {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  token     String    @unique
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")
  user      SiteUser  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("user_password_reset_tokens")
}

model Account {
  id                   String    @id @default(uuid())
  userId               String
  accountId            String
  providerId           String
  password             String?
  accessToken          String?
  refreshToken         String?
  idToken              String?
  expiresAt            DateTime?
  accessTokenExpiresAt DateTime?
  scope                String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  user                 SiteUser  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("accounts")
}

model Verification {
  id         String   @id @default(uuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
  @@map("verifications")
}

model AuditLog {
  id           String     @id @default(uuid())
  adminId      String?
  userId       String?    @map("user_id")
  email        String?
  action       String
  resource     String?
  details      Json?
  ipAddress    String?    @map("ip_address")
  userAgent    String?    @map("user_agent")
  createdAt    DateTime   @default(now())
  tenantId     String?    @map("tenant_id")
  resourceType String?    @map("resource_type")
  resourceId   String?    @map("resource_id")
  userRole     String?    @map("user_role")
  admin        SiteUser?  @relation("AdminAuditLogs", fields: [adminId], references: [id])
  user         SiteUser?  @relation("UserAuditLogs", fields: [userId], references: [id])
  tenant       Tenant?    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([action])
  @@index([createdAt])
  @@index([resourceId])
  @@index([tenantId])
  @@index([userId])
  @@index([email])
  @@index([userRole])
  @@map("audit_logs")
}


// ============================================================================
// ROLE-BASED ACTIVITY LOG ARCHIVES (Stage 1: Hot â†’ Warm Storage)
// ============================================================================

model PlayerActivityArchive {
  id            String    @id @default(uuid())
  userId        String    @map("user_id")
  email         String?
  action        String
  resource      String?
  resourceType  String?   @map("resource_type")
  resourceId    String?   @map("resource_id")
  details       Json?
  ipAddress     String?   @map("ip_address")
  userAgent     String?   @map("user_agent")

  // Archive metadata
  originalLogId String?   @map("original_log_id")
  archivedAt    DateTime  @default(now()) @map("archived_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  // GDPR compliance
  isAnonymized  Boolean   @default(false) @map("is_anonymized")
  anonymizedAt  DateTime? @map("anonymized_at")

  @@index([userId])
  @@index([email])
  @@index([action])
  @@index([createdAt])
  @@index([archivedAt])
  @@index([isAnonymized])
  @@map("player_activity_archive")
}

model AdminActivityArchive {
  id            String    @id @default(uuid())
  userId        String    @map("user_id")
  email         String?
  action        String
  resource      String?
  resourceType  String?   @map("resource_type")
  resourceId    String?   @map("resource_id")
  details       Json?
  ipAddress     String?   @map("ip_address")
  userAgent     String?   @map("user_agent")
  userRole      String?   @map("user_role")
  tenantId      String?   @map("tenant_id")

  // Archive metadata
  originalLogId String?   @map("original_log_id")
  archivedAt    DateTime  @default(now()) @map("archived_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  // GDPR compliance
  isAnonymized  Boolean   @default(false) @map("is_anonymized")
  anonymizedAt  DateTime? @map("anonymized_at")

  @@index([userId])
  @@index([email])
  @@index([action])
  @@index([createdAt])
  @@index([archivedAt])
  @@index([isAnonymized])
  @@index([userRole])
  @@index([tenantId])
  @@map("admin_activity_archive")
}

model StreamerActivityArchive {
  id            String    @id @default(uuid())
  userId        String    @map("user_id")
  email         String?
  action        String
  resource      String?
  resourceType  String?   @map("resource_type")
  resourceId    String?   @map("resource_id")
  details       Json?
  ipAddress     String?   @map("ip_address")
  userAgent     String?   @map("user_agent")
  userRole      String?   @map("user_role")
  tenantId      String?   @map("tenant_id")

  // Archive metadata
  originalLogId String?   @map("original_log_id")
  archivedAt    DateTime  @default(now()) @map("archived_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  // GDPR compliance
  isAnonymized  Boolean   @default(false) @map("is_anonymized")
  anonymizedAt  DateTime? @map("anonymized_at")

  @@index([userId])
  @@index([email])
  @@index([action])
  @@index([createdAt])
  @@index([archivedAt])
  @@index([isAnonymized])
  @@index([userRole])
  @@index([tenantId])
  @@map("streamer_activity_archive")
}

model SystemActionArchive {
  id            String    @id @default(uuid())
  // System actions use "system" as userId identifier
  userId        String    @map("user_id") // Always "system" for system-run tasks
  action        String
  resource      String?
  resourceType  String?   @map("resource_type")
  resourceId    String?   @map("resource_id")
  details       Json?

  // Archive metadata
  originalLogId String?   @map("original_log_id")
  archivedAt    DateTime  @default(now()) @map("archived_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  // GDPR compliance
  isAnonymized  Boolean   @default(false) @map("is_anonymized")
  anonymizedAt  DateTime? @map("anonymized_at")

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@index([archivedAt])
  @@index([isAnonymized])
  @@map("system_action_archive")
}

model UploadLog {
  id          String   @id @default(uuid())
  filename    String
  folderPath  String
  fileType    String
  fileSize    BigInt
  blobUrl     String
  adminUserId String
  uploadedAt  DateTime @default(now())
  category    String?
  tags        String[]

  @@index([adminUserId])
  @@index([folderPath])
  @@index([uploadedAt])
  @@index([category])
  @@map("upload_log")
}

model WidgetRolePermission {
  id        String   @id @default(uuid())
  widgetId  String   @unique
  roles     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([widgetId])
  @@map("widget_role_permissions")
}

model UserDashboardPreference {
  id          String    @id @default(uuid())
  userId      String    @unique
  preferences Json
  updatedAt   DateTime  @updatedAt
  user        SiteUser  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_dashboard_preferences")
}

// ============================================================================
// TENANT MODELS (Multi-tenant configuration and management)
// ============================================================================

model Tenant {
  id                         String           @id @default(uuid())
  name                       String
  tenantCode                 String           @unique
  url                        String           @unique
  longName                   String
  shortName                  String
  primaryColor               String?
  secondaryColor             String?
  backgroundColor            String?
  fontColor                  String?
  fontFamily                 String?
  favicon                    String?
  logoMain                   String?
  logoSmall                  String?
  logoDark                   String?
  logoLight                  String?
  prizeIcons                 Json?
  socialMedia                Json?
  streamingPlatforms         Json?
  streamers                  Json?
  jsonFileUrl                String?
  createdAt                  DateTime         @default(now())
  updatedAt                  DateTime         @updatedAt
  customCancelledMessage     String?
  customLiveMessage          String?
  customNextMessage          String?
  customOfflineMessage       String?
  customStartingSoonMessage  String?
  gracePeriodAfterMinutes    Int?
  gracePeriodBeforeMinutes   Int?
  showOtherTenantsCalendars  Boolean          @default(false)
  streamDurationWarningHours Int?
  timezone                   String           @default("UTC")
  colorDark                  String?          @unique
  colorLight                 String?          @unique
  users                      SiteUser[]
  signupUsers                SiteUser[]       @relation("SignupTenant")
  audit_logs                 AuditLog[]
  manualOverrides            ManualOverride[]
  schedules                  StreamSchedule[]
  userTenants                UserTenant[]
  rules                      Rule[]

  @@index([name])
  @@index([tenantCode])
  @@index([url])
  @@map("tenants")
}

model UserTenant {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  tenantId  String    @map("tenant_id")
  createdAt DateTime  @default(now())
  createdBy String?   @map("created_by")
  isActive  Boolean   @default(true) @map("is_active")
  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      SiteUser  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@index([isActive])
  @@map("user_tenants")
}

model RolePermission {
  id          String   @id @default(uuid())
  role        String
  permission  String
  isAllowed   Boolean  @default(false) @map("is_allowed")
  description String?
  category    String?
  modifiedBy  String?  @map("modified_by")
  modifiedAt  DateTime @updatedAt @map("modified_at")
  createdAt   DateTime @default(now()) @map("created_at")

  @@unique([role, permission])
  @@index([role])
  @@index([permission])
  @@map("role_permissions")
}

model GlobalSettings {
  id                         String   @id @default(uuid())
  defaultLiveMessage         String   @default("ðŸ”´ LIVE NOW with {streamer}!")
  defaultNextMessage         String   @default("Next stream: {time} with {streamer}")
  defaultOfflineMessage      String   @default("No streams scheduled at this time")
  defaultCancelledMessage    String   @default("Stream cancelled: {reason}")
  defaultStartingSoonMessage String   @default("ðŸŽ¬ Starting soon: {streamer} goes live at {time}")
  gracePeriodBeforeMinutes   Int      @default(15)
  gracePeriodAfterMinutes    Int      @default(30)
  streamDurationWarningHours Int      @default(6)
  archiveRetentionDays       Int      @default(90)
  createdAt                  DateTime @default(now()) @map("created_at")
  updatedAt                  DateTime @updatedAt @map("updated_at")
  defaultTimezone            String   @default("UTC") @map("default_timezone")

  @@map("global_settings")
}

// ============================================================================
// STREAMING MODELS (Stream scheduling and management)
// ============================================================================

model StreamSchedule {
  id                        String         @id @default(uuid())
  tenantId                  String
  streamerName              String
  startDateTime             DateTime
  endDateTime               DateTime
  isRecurring               Boolean        @default(false)
  rruleString               String?
  customLiveMessage         String?
  customNextMessage         String?
  customCancelledMessage    String?
  customStartingSoonMessage String?
  status                    StreamStatus   @default(SCHEDULED)
  cancellationReason        String?
  archivedAt                DateTime?
  archiveExportId           String?
  createdAt                 DateTime       @default(now())
  updatedAt                 DateTime       @updatedAt
  archiveExport             ArchiveExport? @relation(fields: [archiveExportId], references: [id])
  tenant                    Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([startDateTime])
  @@index([status])
  @@index([archivedAt])
  @@map("stream_schedules")
}

model ManualOverride {
  id            String    @id @default(uuid())
  tenantId      String
  streamerName  String
  customMessage String?
  startedAt     DateTime  @default(now())
  endsAt        DateTime
  endedEarly    Boolean   @default(false)
  endedAt       DateTime?
  createdById   String?
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([startedAt])
  @@index([endsAt])
  @@map("manual_overrides")
}

model ArchiveExport {
  id             String           @id @default(uuid())
  blobUrl        String
  recordCount    Int
  dateRangeStart DateTime
  dateRangeEnd   DateTime
  fileSize       BigInt
  createdAt      DateTime         @default(now())
  schedules      StreamSchedule[]

  @@index([createdAt])
  @@map("archive_exports")
}

enum StreamStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
  POSTPONED
}

// ============================================================================
// PAGE MODELS (Content management system)
// ============================================================================

model Page {
  id                  String    @id @default(uuid())
  title               String
  slug                String
  topic               String?
  parentPageId        String?
  blocksJson          Json      @default("[]")
  searchableText      String?
  order               Int       @default(0)
  versionNumber       Int       @default(1)

  // SEO Metadata
  metaTitle           String?
  metaDescription     String?
  keywords            String?
  ogTitle             String?
  ogDescription       String?
  ogImageUrl          String?
  twitterCardType     String?   @default("summary")
  twitterTitle        String?
  twitterDescription  String?
  twitterImageUrl     String?

  // Publishing
  status              String    @default("draft")
  tenantAssignment    Json      @default("\"all\"")
  publishFromDate     DateTime?
  lastPublishedAt     DateTime?

  // Auto-save tracking
  lastAutoSaveAt      DateTime?
  lastManualSaveAt    DateTime?
  hasUnsavedChanges   Boolean   @default(false)

  // Audit
  createdBy           String
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  parentPage          Page?         @relation("PageHierarchy", fields: [parentPageId], references: [id], onDelete: SetNull)
  childPages          Page[]        @relation("PageHierarchy")
  versions            PageVersion[]

  @@index([slug])
  @@index([topic])
  @@index([status])
  @@index([parentPageId])
  @@index([order])
  @@map("pages")
}

model PageVersion {
  id               String   @id @default(uuid())
  pageId           String
  versionNumber    Int
  pageData         String
  metadataSnapshot String
  originalSize     Int
  createdBy        String
  createdAt        DateTime @default(now())

  page             Page     @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@unique([pageId, versionNumber])
  @@index([pageId])
  @@map("page_versions")
}

model PublishedPage {
  id              String    @id @default(uuid())
  pageId          String
  tenantId        String?
  slug            String
  title           String
  description     String?
  topic           String?
  contentUrl      String
  hierarchyData   Json
  publishFromDate DateTime?
  publishedAt     DateTime  @default(now())
  order           Int       @default(0)

  @@unique([pageId, tenantId])
  @@index([tenantId])
  @@index([slug])
  @@index([order])
  @@map("published_pages")
}

// ============================================================================
// SCHEDULED TASKS (Background job management)
// ============================================================================

model ScheduledTask {
  id                String                 @id @default(uuid())

  // Handler reference
  taskKey           String                 @unique
  label             String
  description       String?

  // Schedule configuration
  scheduleType      ScheduleType
  scheduleConfig    Json                   // { type: 'interval', seconds: 86400 } or { type: 'cron', expression: '0 2 * * *' } or { type: 'once', runAt: 'ISO8601' }
  taskPayload       Json                   // Validated against handler schema

  // Activation status
  active            Boolean                @default(true)
  paused            Boolean                @default(false)

  // Execution order (higher = runs first)
  executionOrder    Int                    @default(100) @map("execution_order")

  // Run tracking
  lastRunAt         DateTime?              @map("last_run_at")
  lastRunStatus     TaskRunStatus          @default(pending) @map("last_run_status")
  lastRunMessage    String?                @map("last_run_message")
  lastRunDuration   Int?                   @map("last_run_duration")  // Milliseconds
  nextRunAt         DateTime?              @map("next_run_at")

  // Error tracking
  errorCount        Int                    @default(0) @map("error_count")
  lastErrorAt       DateTime?              @map("last_error_at")
  lastErrorMessage  String?                @map("last_error_message")

  // Attribution: Creator and updater
  createdBy         String
  createdById       String                 @map("created_by_id")
  updatedBy         String?                @map("updated_by")
  updatedById       String?                @map("updated_by_id")

  // Soft delete
  deletedAt         DateTime?              @map("deleted_at")
  deletedBy         String?                @map("deleted_by")
  deletedById       String?                @map("deleted_by_id")

  // Timestamps
  createdAt         DateTime               @default(now()) @map("created_at")
  updatedAt         DateTime               @updatedAt @map("updated_at")

  // Relations
  logs              ScheduledTaskLog[]
  createdByUser     SiteUser               @relation("ScheduledTaskCreatedBy", fields: [createdById], references: [id])
  updatedByUser     SiteUser?              @relation("ScheduledTaskUpdatedBy", fields: [updatedById], references: [id])
  deletedByUser     SiteUser?              @relation("ScheduledTaskDeletedBy", fields: [deletedById], references: [id])

  @@index([active])
  @@index([paused])
  @@index([nextRunAt])
  @@index([createdAt])
  @@index([taskKey])
  @@index([lastRunStatus])
  @@map("scheduled_tasks")
}

model ScheduledTaskLog {
  id                 String              @id @default(uuid())

  // Task reference
  taskId             String              @map("task_id")
  task               ScheduledTask       @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Execution details
  runStartedAt       DateTime            @map("run_started_at")
  runFinishedAt      DateTime?           @map("run_finished_at")
  status             TaskLogStatus       // 'success' | 'error'
  message            String
  errorStack         String?             @map("error_stack")

  // Duration tracking
  durationMs         Int?                @map("duration_ms")  // Milliseconds

  // Execution context
  runBySystem        Boolean             @default(false) @map("run_by_system")
  runTriggeredBy     String?             @map("run_triggered_by")
  runTriggeredById   String?             @map("run_triggered_by_id")
  runTriggeredByRole String?             @map("run_triggered_by_role")  // Cached role at time of run

  createdAt          DateTime            @default(now()) @map("created_at")

  // Relations
  runTriggeredByUser SiteUser?           @relation("ScheduledTaskLogTriggeredBy", fields: [runTriggeredById], references: [id], onDelete: SetNull)

  @@index([taskId])
  @@index([status])
  @@index([createdAt])
  @@map("scheduled_task_logs")
}

// ============================================================================
// SEASONS & GAMIFICATION
// ============================================================================

model Season {
  id                  String    @id @default(uuid())
  name                String
  slug                String    @unique
  description         String?
  start_date          DateTime
  end_date            DateTime

  // Season status (DRAFT, ACTIVE, GRACE, ARCHIVED)
  status              String    @default("DRAFT")

  // Grace period configuration
  grace_period_days   Int       @default(7)
  grace_period_started_at DateTime?
  grace_expires_at    DateTime?

  // Comeback bonuses (configurable per season)
  comeback_bonus_enabled    Boolean    @default(true)
  comeback_bonus_24h        Int        @default(100)
  comeback_bonus_48h        Int        @default(75)
  comeback_bonus_72h        Int        @default(50)
  comeback_bonus_daily      Int        @default(25)

  // Archive
  archived_at         DateTime?
  archive_url         String?

  created_at          DateTime  @default(now())
  updated_at          DateTime  @updatedAt

  // Relations
  ranks               Rank[]
  user_points         UserPoints[]
  user_streaks        UserStreak[]
  transactions        PointTransaction[]
  holidays            SeasonHoliday[]

  @@index([status])
  @@index([grace_expires_at])
  @@map("seasons")
}

model Rank {
  id                String   @id @default(uuid())
  season_id         String
  rank_number       Int
  name              String
  min_xp            Int
  max_xp            Int
  xp_per_point      Decimal  @db.Decimal(10, 4)
  coupons_per_point Decimal? @db.Decimal(10, 4)
  daily_xp_decay    Int      @default(0)
  badge_color       String?
  badge_icon        String?
  active            Boolean  @default(true)
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  // Relations
  season            Season   @relation(fields: [season_id], references: [id], onDelete: Cascade)

  @@unique([season_id, rank_number])
  @@index([season_id, min_xp, max_xp])
  @@map("ranks")
}

model SeasonHoliday {
  id                String      @id @default(cuid())
  season_id         String
  name              String
  start_date        DateTime
  end_date          DateTime
  created_at        DateTime    @default(now())

  season            Season      @relation(fields: [season_id], references: [id], onDelete: Cascade)

  @@index([season_id])
  @@index([start_date, end_date])
  @@unique([season_id, name])
  @@map("season_holidays")
}

model Mine {
  id              String   @id @default(uuid())
  name            String   @unique
  display_name    String
  description     String?
  active          Boolean  @default(true)
  trigger_count   Int      @default(0)
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  // Relations
  rules           Rule[]

  @@map("mines")
}

model Rule {
  id                    String   @id @default(uuid())
  mine_id               String
  tenant_id             String?
  season_id             String?
  name                  String
  description           String?

  // Reward Configuration
  points_reward         Int
  xp_reward             Int      @default(0)

  // Cooldown Configuration
  cooldown_type         String                    // "none" | "fixed_interval" | "daily" | "weekly" | "once_per_season"
  cooldown_seconds      Int      @default(0)

  // Temporal Conditions
  day_of_week_restriction  Int[]  @default([])
  date_restriction         DateTime?
  date_range_start         DateTime?
  date_range_end           DateTime?

  // Streak & Bonus Configuration
  streak_eligible          Boolean  @default(false)
  apply_streak_multiplier  Boolean  @default(true)
  bonus_multiplier         Decimal  @db.Decimal(10, 4) @default(1.0)

  // Execution
  priority                 Int      @default(0)
  active                   Boolean  @default(true)
  created_at               DateTime @default(now())
  updated_at               DateTime @updatedAt

  // Relations
  mine                  Mine     @relation(fields: [mine_id], references: [id], onDelete: Cascade)
  tenant                Tenant?  @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@index([mine_id, active])
  @@index([tenant_id])
  @@index([season_id])
  @@index([date_restriction])
  @@map("rules")
}

model UserPoints {
  id                      String   @id @default(uuid())
  user_id                 String   @map("user_id")
  season_id               String   @map("season_id")

  // Point balances
  points_balance          Int      @default(0)    @map("points_balance")
  total_points_earned     Int      @default(0)    @map("total_points_earned")
  total_xp                Int      @default(0)    @map("total_xp")
  current_rank            String?  @map("current_rank")

  // Decay tracking
  decay_window            String   @default("24h")  @map("decay_window")
  decay_period_count      Int      @default(0)    @map("decay_period_count")
  decay_started_at        DateTime? @map("decay_started_at")

  // Activity tracking
  last_activity           DateTime? @map("last_activity")
  last_mine_execution_id  String?  @map("last_mine_execution_id")
  last_mine_timestamp     DateTime? @map("last_mine_timestamp")

  // Concurrency control
  concurrent_lock_token   String?  @map("concurrent_lock_token")
  concurrent_lock_expires DateTime? @map("concurrent_lock_expires")

  created_at              DateTime @default(now()) @map("created_at")
  updated_at              DateTime @updatedAt @map("updated_at")

  // Relations
  season                Season     @relation(fields: [season_id], references: [id], onDelete: Cascade)
  transactions          PointTransaction[]

  @@unique([user_id, season_id])
  @@index([season_id])
  @@index([user_id])
  @@index([current_rank])
  @@map("user_points")
}

model PointTransaction {
  id                  String   @id @default(uuid())
  user_points_id      String   @map("user_points_id")
  user_id             String   @map("user_id")
  season_id           String   @map("season_id")

  // Transaction type
  transaction_type    String                       // "points_earned", "points_spent", "points_adjusted", "xp_gained", "rank_up", etc.
  points_change       Int      @default(0)         @map("points_change")
  xp_change           Int      @default(0)         @map("xp_change")

  // References
  rule_id             String?  @map("rule_id")
  mine_id             String?  @map("mine_id")
  tenant_id           String?  @map("tenant_id")
  reference_id        String?  @map("reference_id")   // For linking to external events

  // Metadata
  notes               String?
  metadata            Json?
  admin_user_id       String?  @map("admin_user_id")

  created_at          DateTime @default(now()) @map("created_at")

  // Relations
  user_points        UserPoints  @relation(fields: [user_points_id], references: [id], onDelete: Cascade)
  season             Season      @relation(fields: [season_id], references: [id], onDelete: Cascade)

  @@index([user_points_id])
  @@index([user_id])
  @@index([season_id])
  @@index([transaction_type])
  @@index([created_at])
  @@index([mine_id])
  @@map("points_transactions")
}

model UserStreak {
  id                String   @id @default(uuid())
  user_id           String   @map("user_id")
  season_id         String   @map("season_id")
  tenant_id         String?  @map("tenant_id")
  mine_id           String   @map("mine_id")

  // Streak data
  current_streak    Int      @default(0)  @map("current_streak")
  longest_streak    Int      @default(0)  @map("longest_streak")

  // Activity tracking
  last_activity     DateTime? @map("last_activity")
  bonus_multiplier  Decimal   @db.Decimal(10, 4) @default(1.0) @map("bonus_multiplier")

  created_at        DateTime @default(now()) @map("created_at")
  updated_at        DateTime @updatedAt @map("updated_at")

  // Relations
  season            Season   @relation(fields: [season_id], references: [id], onDelete: Cascade)

  @@unique([user_id, season_id, mine_id])
  @@index([user_id])
  @@index([season_id])
  @@index([mine_id])
  @@map("user_streaks")
}

// ============================================================================
// MINE TRIGGER SECURITY
// ============================================================================

model MineTriggeredToken {
  id                String    @id @default(uuid())
  token             String    @unique
  user_id           String    @map("user_id")
  mine_id           String    @map("mine_id")
  tenant_id         String    @map("tenant_id")

  // One-time use tracking
  used              Boolean   @default(false)
  used_at           DateTime? @map("used_at")

  // Token expiration
  expires_at        DateTime  @map("expires_at")

  // Metadata
  created_at        DateTime  @default(now()) @map("created_at")

  @@index([token])
  @@index([user_id])
  @@index([mine_id])
  @@index([tenant_id])
  @@index([expires_at])
  @@map("mine_triggered_tokens")
}

enum ScheduleType {
  interval
  cron
  once
}

enum TaskRunStatus {
  success
  error
  running
  pending
  skipped
}

enum TaskLogStatus {
  success
  error
}
